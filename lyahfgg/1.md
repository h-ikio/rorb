# はじめの第一歩

負数を表すのに () でくくらないといけないらしい。

```

ghci> 1 + -1
<interactive>:18:1:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infix expression
ghci> 1 + (-1)
0
```

ブーリアンの否定は```not```。

また、比較演算子の```等しくない```は```/= ```。

整数は浮動小数型としても扱えるらしい。

## 1.1 関数呼び出し

```*``` は実は関数で２つの数を引数に取っている(中置関数)。ほとんどの関数は前置き関数。

2引数の関数は、関数をバッククォートで囲むと中置関数として呼び出せる。

```
ghci> 92 `div` 10
9
```

## 1.2 赤ちゃんの最初の関数

if は else節が必須。値を返す式であるため。

関数名にアポストロフィを使うことができ、慣習的に正格版の関数や少し変更したバージョンの関数名に使われる。

関数名は大文字で始めることができない。

引数を受け取らない関数は定義とか名前とか呼ばれる。

## 1.3 リスト入門

あるリストが格納できるのは同じ型のものに限る。

リストは各カッコで括る。

連結の演算子は ```++```。末尾に連結するので、最初のリストを最後まで操作する。

consの演算子は ```:```。これは先頭に追加する。

```++``` の引数は両方リストだが、```:```では第一引数の型は第二引数のリストの要素の型である。

```[1,2,3]``` は、```1:2:3:[]``` の糖衣構文である。

indexでアクセスするときは ```!!``` 演算子を使う。indexは0オリジン。

リストの中にリストを含むことができるが、それぞれの要素の型は同じである必要がある。

リストの要素が比較可能なら、そのリスト同士は演算子によって比較することが可能。辞書順で比較される。

空でないリストは空リストより必ず大きい。


```
ghci> [1,2,3] > [1,2]                                                                    │
True  
```

head/tail/last/init はScalaと同じ。空リストを渡すとエラー。

null関数はリストが空かどうかを返す。

elem関数は要素がリストに含まれるかどうかを返す。

## 1.4 レンジでチン！

rangeは以下のように使える。

```
ghci> [1..10]
[1,2,3,4,5,6,7,8,9,10]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
```

無限リストは以下の様に書ける。

```
ghci> take 10 [1,0..]
[1,0,-1,-2,-3,-4,-5,-6,-7,-8]
```

遅延評価なので無限リストも簡単に書ける。

## 1.5 リスト内包表記

リスト内包表記の例。

```
ghci> [x * 2 | x <- [1 .. 10]]
[2,4,6,8,10,12,14,16,18,20]
```

リストの要素をxに束縛し、それをx*2として出力、という感じに読むらしい。

述語を書くことでフィルタすることが可能。

```
ghci> [x * 2 | x <- [1 .. 10], x * 2 > 10]
[12,14,16,18,20]
```

複数のリストから束縛することが可能。束縛した値を使わない場合は ```_``` を使う。

## 1.6 タプル

タプルは複数の違う型を格納でき、サイズが固定である点がリストと異なる。

タプルはそのサイズも型の一部となるため、サイズ2のタプルとサイズ3のタプルは別の型となる。
